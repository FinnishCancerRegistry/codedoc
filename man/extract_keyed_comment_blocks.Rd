% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect_raw.R
\name{extract_keyed_comment_blocks}
\alias{extract_keyed_comment_blocks}
\alias{extract_keyed_comment_blocks_}
\title{Read codedoc-formatted Code Comments}
\usage{
extract_keyed_comment_blocks(
  text_file_paths,
  detect_comment_lines = function(x) grepl("^\\\\s*[#*]\\\\s*", x),
  clean_comment_lines = function(x) sub("^\\\\s*[#*]\\\\s*", "", x),
  detect_allowed_keys = function(x) rep(TRUE, length(x)),
  readLines_arg_list = list(warn = FALSE),
  string_interpolation_eval_env = parent.frame(1L)
)

extract_keyed_comment_blocks_(
  text_file_paths,
  detect_comment_lines = function(x) grepl("^\\\\s*[#*]\\\\s*", x),
  clean_comment_lines = function(x) sub("^\\\\s*[#*]\\\\s*", "", x),
  detect_allowed_keys = function(x) rep(TRUE, length(x)),
  readLines_arg_list = list(warn = FALSE),
  string_interpolation_eval_env = parent.frame(1L)
)
}
\arguments{
\item{text_file_paths}{\verb{[character]}
(mandatory, no default)

path to a text file; the file is not inspected in any way to be a text file
based on file extension or any other characteristics, it is merely assumed
to be one}

\item{detect_comment_lines}{\verb{[function]}
(optional, default \code{function(x) grepl("^\\\\s*[#*]", x)})

a function which takes lines of text as input and outputs a logical vector
of the same length as input which is \code{TRUE} when the line is a comment line;
the default detects lines that start with the regex \code{"^\\\\s*[#*]\\\\s*"}}

\item{clean_comment_lines}{\verb{[function]}
(optional, default \code{function(x) sub("^\\\\s*[#*]\\\\s*", "", x)})

a function which takes lines of text as input and outputs a character vector
of the same length as input; this function takes comment lines and should
strip any comment characters preceding the text itself;
the default removes any substrings matching regex \code{"^\\\\s*[#*]\\\\s*"}}

\item{detect_allowed_keys}{\verb{[function]}
(optional, default \code{function(x) rep(TRUE, length(x))})

a function which takes a character vector of keys as input and returns a
boolean vector of the same length, where an element is \code{TRUE} for keys
which should be retained (those filtered out should have \code{FALSE});
the default keeps all keys.

this filtering does not affect which comment blocks are read into R; instead
it affects which are processed (inserting + interpolation) and which keys are
returned in output. therefore, comment blocks that need to be inserted into
the ones you want to retain in output are kept for the insertion phase.}

\item{readLines_arg_list}{\verb{[list]}
(optional, default \code{list(warn = FALSE)})

list of arguments passed to \link{readLines}; \code{con} is always set to
an element of \code{text_file_paths}}

\item{string_interpolation_eval_env}{\verb{[environment]}
(optional, default \code{parent.frame(1L)})

environment where string interpolation expressions are evaluated. by default
this is the environment where \code{extract_keyed_comment_blocks} or
\code{extract_keyed_comment_blocks_} is called. see Details for more information.}
}
\description{
Extracts blocks of specifically formatted comments from text file.
}
\details{
\code{extract_keyed_comment_blocks} is intended to be used by the user and not
in other functions but is otherwise identical to
\code{extract_keyed_comment_blocks_}. \code{extract_keyed_comment_blocks_} is intended
to be used within other functions.
See \code{help(topic = "dbc", package = "dbc")} for discussion on this
distinction.

Both insertion of comment blocks into other comment blocks and simple string
interpolation is possible. Insertion is performed before any interpolation.

Insertion of comment blocks into other comment blocks is implemented
as follows:
\itemize{
\item lines with insert keys are detected using regex
"@codedoc_insert_comment_block"
\item all lines are passed through a maximum of ten times. this means
that a recursion depth of ten is the maximum. recursion can occur
if a comment block is inserted which in turn has one or more
insert keys.
\item insert keys are collected by removing the regex given above,
anything preceding it, and all whitespaces after it
\item each line with an insert key is effectively replaced with
all lines in the comment block of that key (e.g. line with key
"my_key" is replaced with all lines in comment block with key
"my_key"). this is run separately for each detected insert key.
\item the result is still a character vector, but here the insert keys
have been replaced with lines from the comment blocks under those keys
}

Simple string interpolation is implemented
as follows:
\itemize{
\item interpolation expressions are detected using regex
\verb{[$][\{][^\}]*[\}]}
\item each collected unique expression is evaluated using eval()
\item if an expression produces an object of length more than one,
separate elements are pasted together with one whitespace as a
separator
\item each expressions' results are inserted back into text using gsub
}

String interpolation is applied after any comment block insertions.
It is performed on both each \code{comment_block} element and on each
\code{key}. This means that even the keys can be defined programmatically.
}
\examples{

block_df <- codedoc::extract_keyed_comment_blocks_(
  text_file_paths = codedoc::example_text_file_path("r_script.R")
)
print(block_df)

}
