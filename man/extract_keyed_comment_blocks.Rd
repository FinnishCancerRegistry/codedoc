% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect_raw.R
\name{extract_keyed_comment_blocks}
\alias{extract_keyed_comment_blocks}
\title{Read codedoc-formatted Code Comments}
\usage{
extract_keyed_comment_blocks(
  text_file_paths = NULL,
  detect_comment_lines = NULL,
  clean_comment_lines = NULL,
  detect_allowed_keys = "",
  sort_by = NULL,
  readLines_arg_list = list(warn = FALSE),
  string_interpolation_eval_env = parent.frame(1L),
  assertion_type = "input"
)
}
\arguments{
\item{text_file_paths}{\verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: collect text file paths using call
}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{dir(
path = getwd(),
pattern = "[.]((r)|(rmd)|(py)|(sql)|(cpp)|(hpp)|(c)|(h))$",
full.names = TRUE,
recursive = TRUE,
ignore.case = TRUE
)
}\if{html}{\out{</div>}}
\itemize{
\item \code{character}: use these text files
}}

\item{detect_comment_lines}{\verb{[NULL, character, function]}
(default \code{NULL})
\itemize{
\item \code{NULL}: Use these:
\code{c(r = "^\\\\s*[#]+\\\\s*", rmd = "^\\\\s*[#]+\\\\s*", py = "^\\\\s*[#]+\\\\s*", sql = "^\\\\s*[-]{2,}\\\\s*", cpp = "^\\\\s*[/]{2,}\\\\s*", hpp = "^\\\\s*[/]{2,}\\\\s*", c = "^\\\\s*[/]{2,}\\\\s*", h = "^\\\\s*[/]{2,}\\\\s*")}
\item \code{character}: One or more regular expressions that a line must match to
be considered a comment line. You can supply file type-specific regexes
by using (lowercase) file type names as names of the vector. E.g.
\code{c(r = "^ *#+ *", sql = "^ *--{2,} *")}.
\item \code{function}: A function which takes lines of text as input and outputs a
logical vector of the same length as input which is \code{TRUE} when the line
is a comment line. If the function has argument \code{file_type}, the file
type / file extensions (e.g. \code{"r"}) is supplied to it when called.
}}

\item{clean_comment_lines}{\verb{[NULL, character, function]} (default \code{NULL})
\itemize{
\item \code{NULL}: If \code{detect_comment_lines} was \code{character}, use that.
Else use these:
\code{c(r = "^\\\\s*[#]+\\\\s*", rmd = "^\\\\s*[#]+\\\\s*", py = "^\\\\s*[#]+\\\\s*", sql = "^\\\\s*[-]{2,}\\\\s*", cpp = "^\\\\s*[/]{2,}\\\\s*", hpp = "^\\\\s*[/]{2,}\\\\s*", c = "^\\\\s*[/]{2,}\\\\s*", h = "^\\\\s*[/]{2,}\\\\s*")}.
\item \code{character}: One ore more regexes. Just like with
\code{detect_comment_lines}, can be file type-specific.
\item \code{function}: A function which takes lines of text as input and outputs a
character vector of the same length. This function takes comment
lines and should strip any comment characters preceding the text itself.
You can also here use the \code{file_type} argument.
}}

\item{detect_allowed_keys}{\verb{[character, function]}
(optional, default \code{""})
\itemize{
\item \code{character}: pass this string as arg \code{pattern} to \verb{[grepl]}
\item \code{function}:   a function which takes a character vector of keys as input
and returns a boolean vector of the same length, where an element is
\code{TRUE} for keys which should be retained (those filtered out should have
\code{FALSE})
}

this filtering does not affect which comment blocks are read into R; instead
it affects which are processed (inserting + interpolation) and which keys are
returned in output. therefore, comment blocks that need to be inserted into
the ones you want to retain in output are kept for the insertion phase.}

\item{sort_by}{\verb{[NULL, character]} (default \code{NULL})

Names of columns by which to sort output \code{block_df}.
Each column name must be one of the following:
c("text_file_path", "key", "first_block_line", "last_block_line",  "comment_block")
\itemize{
\item \code{NULL}: Use \code{c("text_file_path", "first_block_line")}.
\item \code{character}: Sort output \code{block_df} by these columns.
}}

\item{readLines_arg_list}{\verb{[list]}
(optional, default \code{list(warn = FALSE)})

list of arguments passed to \link{readLines}; \code{con} is always set to
an element of \code{text_file_paths}}

\item{string_interpolation_eval_env}{\verb{[environment]}
(optional, default \code{parent.frame(1L)})

Environment where string interpolation expressions are evaluated. By default
this is the environment where \code{extract_keyed_comment_blocks} is called.
See Details for more information.}

\item{assertion_type}{see \verb{[dbc::report_to_assertion]}}
}
\description{
Extracts blocks of specifically formatted comments from text file.
}
\details{
\strong{Text extraction}

The following steps are performed to extract text data from each given
\code{text_file_paths} path:
\itemize{
\item Each whole text file is read into R using \link{readLines}
\item Comment lines are identified by calling \code{detect_comment_lines}.
\item Key lines are identified by calling \code{detect_codedoc_key_lines}
on identified comment lines.
\item Keys are collected
\item The number of appearances of each key is verified to be an even number
\item Each comment block is collected from the text
\item Comment blocks are sorted by the first and last line number of the block,
respectively
}

All results from all given \code{text_file_paths} are collected into one
\code{data.frame}.

\strong{Comment block insertion}

Comment block insertion is performed as follows:
\itemize{
\item Allowed keys are identified using \code{detect_allowed_keys}
}

\itemize{
\item Insertion is performed on only the blocks with allowed keys
(but blocks with non-allowed keys can contain data for insertion into
blocks with allowed keys)
\item lines with insert keys are detected using regex
"@codedoc_insert_comment_block"
\item all lines are passed through a maximum of ten times. this means
that a recursion depth of ten is the maximum. recursion can occur
if a comment block is inserted which in turn has one or more
insert keys.
\item insert keys are collected by removing the regex given above,
anything preceding it, and all whitespaces after it
\item each line with an insert key is effectively replaced with
all lines in the comment block of that key (e.g. line with key
"my_key" is replaced with all lines in comment block with key
"my_key"). this is run separately for each detected insert key.
\item the result is still a character vector, but here the insert keys
have been replaced with lines from the comment blocks under those keys
}

After insertion, all data with non-allowed keys are dropped.

\strong{String interpolation}

String interpolation is applied after any comment block insertions.
It is performed on both each \code{comment_block} element and on each
\code{key}. This means that even the keys can be defined programmatically.
Interpolation is performed as follows:
\itemize{
\item interpolation expressions are detected using regex
\verb{[$][\{][^\}]*[\}]}
\item each collected unique expression is evaluated using eval()
\item if an expression produces an object of length more than one,
separate elements are pasted together with one whitespace as a
separator
\item each expressions' results are inserted back into text using gsub
}

\strong{Last steps}

Finally, duplicate rows in the \code{data.frame} of comment blocks are removed,
where duplicates those with non-unique combinations of the \code{key} and
\code{comment_block} columns. This means that the same data collected from
two different files (or the same file) are not retained.

The \code{data.frame} is sorted into descending order by columns
given via arg \code{sort_by}.

This concludes comment block extraction.
}
